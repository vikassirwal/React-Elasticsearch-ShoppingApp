import { Children, Component, createElement } from 'react';
import PropTypes from 'prop-types';
import hoistNonReactStatics from 'hoist-non-react-statics';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

// https://github.com/styled-components/styled-components/blob/e05b3fe247e9d956bcde786cec376e32afb85bca/src/utils/create-broadcast.js
var createBroadcast = function createBroadcast(initialState) {
  var listeners = {};
  var id = 0;
  var state = initialState;

  function publish(nextState) {
    state = nextState;

    for (var key in listeners) {
      // $FlowFixMe
      var listener = listeners[key];

      if (listener === undefined) {
        continue;
      }

      listener(state);
    }
  }

  function subscribe(listener) {
    var currentId = id;
    listeners[currentId] = listener;
    id += 1;
    listener(state);
    return currentId;
  }

  function unsubscribe(unsubID) {
    listeners[unsubID] = undefined;
  }

  return {
    publish: publish,
    subscribe: subscribe,
    unsubscribe: unsubscribe
  };
};

var channel = '__EMOTION_THEMING__';

var _contextTypes;

var contextTypes = (_contextTypes = {}, _contextTypes[channel] = PropTypes.object, _contextTypes);

// adapted from styled-components' ThemeProvider
// https://github.com/styled-components/styled-components/blob/4503cab5b86aa9ef8314c5baa360a2fbb4812485/src/models/ThemeProvider.js
var isPlainObject = function isPlainObject(test) {
  return Object.prototype.toString.call(test) === '[object Object]';
};

function _componentWillMount() {
  var _this2 = this;

  function _ref2(theme) {
    _this2.outerTheme = theme;

    if (_this2.broadcast !== undefined) {
      _this2.publish(_this2.props.theme);
    }
  }

  // If there is a ThemeProvider wrapper anywhere around this theme provider, merge this theme
  // with the outer theme
  if (this.context[channel] !== undefined) {
    this.unsubscribeToOuterId = this.context[channel].subscribe(_ref2);
  }

  this.broadcast = createBroadcast(this.getTheme(this.props.theme));
}

function _getChildContext() {
  var _ref;

  return _ref = {}, _ref[channel] = {
    subscribe: this.broadcast.subscribe,
    unsubscribe: this.broadcast.unsubscribe
  }, _ref;
}

function _componentWillReceive(nextProps) {
  if (this.props.theme !== nextProps.theme) {
    this.publish(nextProps.theme);
  }
}

function _componentWillUnmount() {
  var themeContext = this.context[channel];

  if (themeContext !== undefined) {
    themeContext.unsubscribe(this.unsubscribeToOuterId);
  }
}

function _getTheme(theme) {
  if (typeof theme === 'function') {
    var mergedTheme = theme(this.outerTheme);

    if (!isPlainObject(mergedTheme)) {
      throw new Error('[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!');
    }

    return mergedTheme;
  }

  if (!isPlainObject(theme)) {
    throw new Error('[ThemeProvider] Please make your theme prop a plain object');
  }

  if (this.outerTheme === undefined) {
    return theme;
  }

  return _extends({}, this.outerTheme, theme);
}

function _publish(theme) {
  this.broadcast.publish(this.getTheme(theme));
}

function _render() {
  if (!this.props.children) {
    return null;
  }

  return Children.only(this.props.children);
}

var ThemeProvider =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(ThemeProvider, _Component);

  function ThemeProvider() {
    var _this;

    _this = _Component.call(this) || this;
    _this.getTheme = _this.getTheme.bind(_this);
    return _this;
  }

  var _proto = ThemeProvider.prototype;
  _proto.componentWillMount = _componentWillMount;
  _proto.getChildContext = _getChildContext;
  _proto.componentWillReceiveProps = _componentWillReceive;
  _proto.componentWillUnmount = _componentWillUnmount; // Get the theme from the props, supporting both (outerTheme) => {} as well as object notation

  _proto.getTheme = _getTheme;
  _proto.publish = _publish;
  _proto.render = _render;
  return ThemeProvider;
}(Component);

ThemeProvider.childContextTypes = contextTypes;
ThemeProvider.contextTypes = contextTypes;

function _componentWillMount$1() {
  var _this = this;

  var themeContext = this.context[channel];

  if (themeContext === undefined) {
    // eslint-disable-next-line no-console
    console.error('[withTheme] Please use ThemeProvider to be able to use withTheme');
    return;
  }

  this.unsubscribeId = themeContext.subscribe(function (theme) {
    _this.setState({
      theme: theme
    });
  });
}

function _componentWillUnmount$1() {
  if (this.unsubscribeId !== -1) {
    this.context[channel].unsubscribe(this.unsubscribeId);
  }
}

var withTheme = function withTheme(Component$$1) {
  var componentName = Component$$1.displayName || Component$$1.name || 'Component';

  function _render() {
    return createElement(Component$$1, _extends({
      theme: this.state.theme
    }, this.props));
  }

  var WithTheme =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(WithTheme, _React$Component);

    function WithTheme() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = WithTheme.prototype;
    _proto.componentWillMount = _componentWillMount$1;
    _proto.componentWillUnmount = _componentWillUnmount$1;
    _proto.render = _render;
    return WithTheme;
  }(Component);

  WithTheme.displayName = "WithTheme(" + componentName + ")";
  WithTheme.contextTypes = contextTypes;
  return hoistNonReactStatics(WithTheme, Component$$1);
};

export { ThemeProvider, withTheme, channel, contextTypes, createBroadcast };
//# sourceMappingURL=index.es.js.map
